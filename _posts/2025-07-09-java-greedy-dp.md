---
title: "Java 알고리즘 전략: 그리디 & 동적 계획법(DP)"
date: 2025-07-09 00:00:00 +0900
categories: [Java, 알고리즘]
tags: [그리디, DP, 동적 계획법, 최적화]
---

문제 해결에서 자주 등장하는 전략이 바로 **그리디(Greedy)** 알고리즘과 **동적 계획법(Dynamic Programming, DP)** 입니다. 두 방법은 접근 방식이 다르며, 사용 조건과 효율성 측면에서 적절히 선택해야 합니다.

## 개념 정리
- **그리디(Greedy)**: 매 순간 최적의 선택을 하며 정답을 찾는 방식
- **DP**: 큰 문제를 작은 문제로 나눠서 해결한 결과를 저장하며 푸는 방식 (Memoization)

## 주요 특징 또는 핵심 포인트
- 그리디: **조건 만족 시 빠르고 간단**, 전역 최적 보장되지 않음
- DP: **부분 문제의 최적해를 이용해 전체 최적해 도출**, 느리지만 정확

## 사용 예시
### 1. 그리디 예시 (거스름돈 문제)
```java
int[] coins = {500, 100, 50, 10};
int count = 0, money = 1260;
for (int coin : coins) {
    count += money / coin;
    money %= coin;
}
System.out.println(count); // 6
```

### 2. DP 예시 (피보나치 수열)
```java
int[] dp = new int[100];
dp[0] = dp[1] = 1;
for (int i = 2; i < 100; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}
System.out.println(dp[99]);
```

## 장점과 한계 또는 고려사항
### 장점
- 그리디: 코드 간결, 구현 쉬움
- DP: 최적 해 보장

### 한계 / 단점 / 주의사항
- 그리디는 항상 정답을 보장하지 않음 → **반례 검증 필수**
- DP는 메모리/시간 자원 소모 큼 → **중복 호출 줄이기** 중요

## 실무 적용 팁 또는 마무리
- 문제에서 그리디로 풀 수 있다는 조건이 명시되어 있거나, 탐욕적 선택이 항상 최적인지 판단 가능할 때 사용
- 점화식을 세우는 연습은 DP 문제 해결에 핵심

---

> 💡 "그리디는 단순하게, DP는 정교하게! 문제의 성격을 먼저 파악하세요."
