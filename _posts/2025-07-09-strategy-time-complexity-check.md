---
title: "시간 복잡도 계산 및 제한선 확인"
date: 2025-07-09 00:00:00 +0900
categories: [코딩테스트 전략, 시간 복잡도]
tags: [시간 복잡도, 연산 횟수, 제한 시간 분석]
---

**시간 복잡도 계산**은 알고리즘 선택의 핵심 기준입니다. 문제를 풀기 전, 예상 연산 횟수와 시간 제한을 비교해 적절한 알고리즘을 선택해야 시간 초과를 피할 수 있습니다.

## 개념 정리
- **시간 복잡도**는 입력 크기(N)에 따른 수행 시간 증가율을 의미
- 일반적으로 1초에 약 **1억(10^8)** 번 연산 가능
- 입력 크기를 기준으로 적절한 알고리즘 골라야 함

## 주요 특징 또는 핵심 포인트
- `N ≤ 10^7` → O(N) 가능
- `N ≤ 10^5` → O(N log N) 가능
- `N ≤ 10^3` → O(N^2) 가능
- 브루트포스 / 백트래킹은 N^3 이상은 위험

## 예시
- N = 100,000 → O(N log N) 이하만 허용됨 → 정렬, 힙, 트리, 세그먼트 트리
- N = 20 이하인데 “모든 경우 탐색” 요구 → 백트래킹, DFS
- “T ≤ 100,000” 테스트 케이스 → 입력 처리 방식 최적화 필요 (BufferedReader 등)

## 장점과 한계 또는 고려사항
### 장점
- 사전에 시간 초과를 예측하고 방지 가능
- 빠른 풀이 전략 수립에 도움

### 한계 / 단점 / 주의사항
- 데이터 크기만 보고 판단하면 안 되고, **중첩 루프 구조**나 입력 방식도 함께 고려해야 함

## 실무 적용 팁 또는 마무리
- 문제 풀기 전 반드시 “N의 범위”와 “시간 제한”부터 확인하세요.
- 익숙한 시간 복잡도별 연산량 가늠표를 머릿속에 익혀두세요.

---

> 💡 "문제 풀이 전에 시간 복잡도를 먼저 보는 습관은 시간 초과 방지의 시작입니다."
