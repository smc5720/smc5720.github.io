---
title: "선택 정렬 (Selection Sort) - 최솟값을 찾아 정렬하기"
excerpt: "선택 정렬의 원리와 구현, 그리고 성능 분석에 대해 알아보자"
categories:
  - Algorithm
tags:
  - Sorting
  - Selection Sort
  - JavaScript
  - Python
toc: true
toc_sticky: true
---

## 선택 정렬이란?

선택 정렬은 배열에서 최솟값을 찾아서 맨 앞으로 이동시키는 방식으로 동작하는 정렬 알고리즘입니다. 각 단계에서 가장 작은 원소를 선택하여 적절한 위치에 배치하는 방식으로, 직관적이고 이해하기 쉬운 알고리즘입니다.

## 알고리즘 동작 원리

1. **배열에서 최솟값을 찾음**
2. **최솟값을 배열의 맨 앞과 교환**
3. **정렬된 부분을 제외하고 나머지에서 최솟값을 찾음**
4. **배열이 정렬될 때까지 반복**

## 시각적 예시

```
초기 배열: [64, 34, 25, 12, 22, 11, 90]

1단계: [64, 34, 25, 12, 22, 11, 90]
       최솟값 11을 찾아 맨 앞과 교환
       → [11, 34, 25, 12, 22, 64, 90]

2단계: [11, 34, 25, 12, 22, 64, 90]
          최솟값 12를 찾아 두 번째 위치와 교환
          → [11, 12, 25, 34, 22, 64, 90]

3단계: [11, 12, 25, 34, 22, 64, 90]
             최솟값 22를 찾아 세 번째 위치와 교환
             → [11, 12, 22, 34, 25, 64, 90]

4단계: [11, 12, 22, 34, 25, 64, 90]
                최솟값 25를 찾아 네 번째 위치와 교환
                → [11, 12, 22, 25, 34, 64, 90]

5단계: [11, 12, 22, 25, 34, 64, 90]
                   최솟값 34는 이미 올바른 위치

6단계: [11, 12, 22, 25, 34, 64, 90]
                      최솟값 64는 이미 올바른 위치

7단계: [11, 12, 22, 25, 34, 64, 90]
                         최솟값 90은 이미 올바른 위치

최종 결과: [11, 12, 22, 25, 34, 64, 90]
```

## JavaScript 구현

```javascript
function selectionSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
        // 최솟값의 인덱스를 찾음
        let minIndex = i;
        
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // 최솟값을 현재 위치와 교환
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }
    
    return arr;
}

// 사용 예시
const array = [64, 34, 25, 12, 22, 11, 90];
console.log("정렬 전:", array);
console.log("정렬 후:", selectionSort(array));
```

## Python 구현

```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # 최솟값의 인덱스를 찾음
        min_index = i
        
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        
        # 최솟값을 현재 위치와 교환
        if min_index != i:
            arr[i], arr[min_index] = arr[min_index], arr[i]
    
    return arr

# 사용 예시
array = [64, 34, 25, 12, 22, 11, 90]
print("정렬 전:", array)
print("정렬 후:", selection_sort(array))
```

## 성능 분석

### 시간 복잡도
- **최선의 경우**: O(n²) - 모든 경우에 동일
- **평균의 경우**: O(n²) - 일반적인 경우
- **최악의 경우**: O(n²) - 역순으로 정렬된 배열

### 공간 복잡도
- **O(1)** - 제자리 정렬 (in-place sorting)

### 안정성
- **불안정 정렬** - 같은 값의 상대적 순서가 바뀔 수 있음

## 장단점

### 장점
- **구현이 간단**하고 이해하기 쉬움
- **제자리 정렬**로 추가 메모리가 필요 없음
- **교환 횟수가 적음** - O(n)번의 교환
- **작은 데이터**에 대해 효율적

### 단점
- **매우 비효율적** - O(n²) 시간 복잡도
- **큰 데이터**에 대해 실용적이지 않음
- **불안정 정렬** - 같은 값의 순서가 보장되지 않음
- **비교 횟수**가 항상 동일함

## 실제 사용 사례

선택 정렬은 다음과 같은 경우에 사용됩니다:

- **알고리즘 학습** - 정렬의 기본 개념 이해
- **작은 배열** (n < 20) - 간단한 구현이 필요한 경우
- **교환 비용이 높은 환경** - 교환 횟수를 최소화해야 하는 경우
- **메모리 제약 환경** - 추가 메모리를 사용할 수 없는 경우

## 다른 정렬 알고리즘과의 비교

| 알고리즘 | 평균 시간복잡도 | 최악 시간복잡도 | 공간복잡도 | 안정성 | 교환 횟수 |
|---------|---------------|---------------|-----------|--------|-----------|
| 선택 정렬 | O(n²) | O(n²) | O(1) | ❌ | O(n) |
| 버블 정렬 | O(n²) | O(n²) | O(1) | ✅ | O(n²) |
| 삽입 정렬 | O(n²) | O(n²) | O(1) | ✅ | O(n²) |
| 퀵 정렬 | O(n log n) | O(n²) | O(log n) | ❌ | O(n log n) |

## 결론

선택 정렬은 교환 횟수가 적다는 장점이 있지만, 시간 복잡도가 O(n²)로 비효율적입니다. 교육 목적이나 매우 작은 데이터셋에서만 사용하는 것이 좋으며, 실제 프로덕션에서는 퀵 정렬, 병합 정렬 등의 효율적인 알고리즘을 사용하는 것이 바람직합니다.

---

**참고 자료:**
- [Selection Sort - GeeksforGeeks](https://www.geeksforgeeks.org/selection-sort/)
- [Selection Sort - Wikipedia](https://en.wikipedia.org/wiki/Selection_sort) 